/*
 * Copyright (C) 2024 Data-Intensive Systems Lab, Simon Fraser University. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Implements a thread-local write-ahead log

#pragma once
#include <atomic>
#include <vector>
#include <string>
#include <filesystem>

#include "log/config.h"
#include "log/defs.h"
#include "log/segment.h"
#include "noname_defs.h"

namespace noname {
namespace dlog {

// A "local" log that is a collection of segments. The typical use case is thread-local write-ahead
// logs - each thread can instantiate a Log to store log records generated by itself. Because of the
// targeted use cases, there is no CC whatsoever.
//
// Note: LSNs across Log are not comparable, but LSNs within each Log carry proper ordering
// information.
struct Log {
  // Source for generating unique Segment IDs
  static std::atomic<uint64_t> segment_id_counter;

  // Segment file name template: tlog-segid
  char segment_name_buf[SEGMENT_FILE_NAME_BUFSZ];

  // Directory storing the segments belonging to this log
  std::string dir;

  // All segments belonging to this log. segments[segments.size()-1] is the currently open segment
  std::vector<noname::log::Segment*> segments;

  // Whether to O_DIRECT for writing segments
  bool direct_io;

  // Segment size
  uint64_t segment_size;

  // Size of a log buffer (in bytes)
  uint32_t log_buffer_size;

  // Two log buffers for double buffering
  char *log_buffers[2];

  // The log buffer currently in use
  char *active_log_buffer;

  // Current offset of the active log buffer
  uint32_t log_buffer_offset;

  // Current LSN
  noname::log::LSN current_lsn;

  // Durable/flushed LSN
  noname::log::LSN durable_lsn;

  // Lock
  std::mutex lock;

  // Constructor
  Log() {}
  explicit Log(log::config_t config);
  Log(const std::string &dir, uint64_t segment_size, uint32_t log_buffer_size,
      bool dio);

  // Destructor
  ~Log();

  // Delete default copy assignment and copy ctor because of the rule of three: https://en.cppreference.com/w/cpp/language/rule_of_three
  Log(const Log &) = delete;
  Log &operator=(const Log &) = delete;

  // Get the currently open segment
  inline noname::log::Segment *CurrentSegment() { return segments[segments.size() - 1]; }

  // Create a new segment when the current segment is about to exceed the max segment size.
  // Returns reference to the newly created segment.
  noname::log::Segment *CreateSegment();

  // Allocate a log block in-place on the currently active log buffer
  // @payload_size: number of bytes (payload) to allocate for this log block
  // @out_lsn: LSN of this log block - will also be the log block's permanent address
  // Returns a pointer to the allocated log block which is directly instantiated on the allocated
  // space in-place.
  noname::log::LogBlock *AllocateLogBlock(uint32_t payload_size,
                                          noname::log::LSN *out_lsn,
                                          uint64_t tid);

  // Switch the two log buffers
  void FlushLogBuffer();

  void PollFlush();

  void LastFlush();
};

struct Logger {
  Logger(const std::filesystem::path &logging_directory, size_t num_of_workers) {
    local_logs.reserve(num_of_workers);
    for (size_t i = 0; i < num_of_workers + 1; i++) {  // Allocate one more for main thread
      constexpr int USERNAME_MAX_SIZE = 32;
      char user[USERNAME_MAX_SIZE];
      getlogin_r(user, USERNAME_MAX_SIZE);

      log::config_t config(false, logging_directory.string(), (uint64_t)16 * 1024 * MB, 32 * MB, true);

      local_logs.push_back(new Log(config));
    }
  }

  ~Logger() {
    for (auto log : local_logs) {
      delete log;
    }
  }

  Log *LocalLog(size_t worker_id) {
    return local_logs[worker_id];
  }

  std::vector<Log *> local_logs;
};

extern std::vector<Log *> dlogs;
extern std::mutex dlog_lock;
extern std::vector<log::LSN> lsns;

Log *GetLog();
void GetLSNs();

}  // namespace dlog
}  // namespace noname
