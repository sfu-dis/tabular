"""
/*
* Copyright (C) 2022 Data-Intensive Systems Lab, Simon Fraser University.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
"""

import configparser
import dataclasses
import os
import re
import sys

HEADER_COMMENT = '''/*
 * Copyright (C) 2022 Data-Intensive Systems Lab, Simon Fraser University. 
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// THIS FILE IS AUTO-GENERATED BY src/config/config.py BASED OFF THE CONTENTS OF src/config/config.ini
// ANY CHANGES TO THIS FILE WILL NOT PERSIST
// TO ADD A CONFIG FLAG ADD A NEW FLAG TO src/config/config.ini
'''

PROJECT_NAMESPACE = 'noname'


@dataclasses.dataclass
class Flag:
    module: str
    identifier: str
    val: str
    cpp_type: str


PY_TYPES = [
    # (type, test)
    (int, int),
    (float, float),
    (bool, lambda x: x.lower() == 'true' or x.lower() == 'false'),
    (str, str),
]

CPP_TYPES = [
    'bool',
    'std::string',
    'string',
    'float',
    'double',
    'uint64_t',
    'uint32_t',
    'int64_t',
    'int32_t',
]

PY_TO_CPP = {
    bool: 'bool',
    str: 'std::string',
    float: 'double',
}


def infer_cpp_type(val: str):
    py_type = None
    for (pt, test) in PY_TYPES:
        try:
            if test(val):
                py_type = pt
                break
        except ValueError:
            pass

    if py_type == int:
        if int(val) < 0:
            return 'int32_t'
        else:
            return 'uint64_t'
    return PY_TO_CPP[py_type]


cpp_identifier_pattern = re.compile('^[A-Za-z_][A-Za-z0-9_]*$')


def parse_identifier(key: str, val: str):
    # replace all whitespace with one space (be forgiving about whitespace)
    lhs = key.split()
    if len(lhs) == 1:
        if not cpp_identifier_pattern.match(key):
            raise ValueError(f'Config.ini: {key} is not a valid c++ identifier')
        return infer_cpp_type(val), key
    elif len(lhs) == 2:
        if lhs[0] not in CPP_TYPES:
            raise ValueError(f'Config.ini: {lhs[0]} is not a supported c++ type')
        if not cpp_identifier_pattern.match(lhs[1]):
            raise ValueError(f'Config.ini: {lhs[1]} is not a valid c++ identifier')
        # add support for shorthand string identifier
        if lhs[0] == 'string':
            return 'std::string', lhs[1]
        else:
            return lhs[0], lhs[1]
    else:
        raise ValueError(f'Config.ini: {key} has too much white space to be a valid identifier')


def parse_config(config_file: str):
    cp = configparser.ConfigParser()
    cp.read(config_file)
    flags = []
    for module in cp.sections():
        keys = set()
        for key in cp[module]:
            val = cp[module][key]
            cpp_type, identifier = parse_identifier(key, val)
            if identifier in keys:
                raise ValueError(f'Config.ini: {identifier} is defined twice in module {module}')
            keys.add(identifier)
            # wrap string in quotes if there are none
            if cpp_type == 'std::string' and val[0] != '"':
                val = f'"{val}"'
            flags.append(Flag(module, identifier, val, cpp_type))
    return cp.sections(), flags


def main_config_str(modules: [str], flags: [Flag]):
    def option_desc(flag: Flag):
        return f'("{flag.module}.{flag.identifier}", po::value<{flag.cpp_type}>()->default_value({flag.val}))'

    option_descs = '\n  '.join(option_desc(flag) for flag in flags)
    if len(option_descs):
        option_descs = '  desc.add_options()\n  ' + option_descs + ';'

    parse_args_cpp = f'''
#include "config.h"

#include <iostream>
#include <string>
#include <boost/program_options/parsers.hpp>
#include <boost/program_options/options_description.hpp>

namespace {PROJECT_NAMESPACE} {{
namespace config {{
namespace po = boost::program_options;
po::variables_map FLAG_STORE;

po::options_description default_options() {{
  po::options_description desc;
{option_descs}
  return desc;
}}

void parse_args(po::options_description desc, int argc, char** argv) {{
  po::store(po::parse_command_line(argc, argv, desc), FLAG_STORE);
  po::notify(FLAG_STORE);

  po::store(po::parse_config_file("config.ini", desc), FLAG_STORE);
  po::notify(FLAG_STORE);
}}
'''

    def module_print(module: str):
        def variable_print(flag: Flag):
            return f'std::cout << "{flag.identifier}: " << config::FLAG_STORE["{flag.module}.{flag.identifier}"].as<{flag.cpp_type}>() << std::endl;'

        variable_prints = '\n  '.join(variable_print(flag) for flag in flags if flag.module == module)
        if len(variable_prints):
            return f'std::cout << "[{module}]" << std::endl;\n  ' + variable_prints
        return f'std::cout << "[{module}]" << std::endl;'

    print_lines = '\n  '.join(module_print(module) for module in modules)
    print_lines_cpp = f'''
void print_config() {{
  {print_lines}
}}
}}  // namespace config
}}  // namespace {PROJECT_NAMESPACE}
'''
    return HEADER_COMMENT + parse_args_cpp + print_lines_cpp


def generate_main_config(path: str, modules: [str], flags: [Flag]):
    with open(os.path.join(path, 'config.cc'), 'w') as file:
        file.write(main_config_str(modules, flags))


def module_config_str(module: str, flags: [Flag]):
    if len(flags) == 0:
        h_config = f'''
#pragma once

namespace {PROJECT_NAMESPACE} {{
namespace {module} {{

typedef struct config_t{{
  config_t() = default;    
  explicit config_t(bool set_default) {{}}
}} config_t;

}}  // namespace {module}
}}  // namespace {PROJECT_NAMESPACE}
    '''
        return HEADER_COMMENT + h_config

    def type_decl(flag: Flag):
        return f'const {flag.cpp_type} {flag.identifier};'

    type_decls = '\n  '.join(type_decl(flag) for flag in flags)

    def configured_decl(flag: Flag):
        return f'{flag.identifier}(config::FLAG_STORE["{flag.module}.{flag.identifier}"].as<{flag.cpp_type}>())'

    configured_vals = '\n  , '.join(configured_decl(flag) for flag in flags)

    def param_decl(flag: Flag):
        return f'{flag.cpp_type} {flag.identifier}={flag.val}'

    param_decls = ', '.join(param_decl(flag) for flag in flags)

    def assigned_val(flag: Flag):
        if flag.cpp_type == 'std::string':
            return f'{flag.identifier}(std::move({flag.identifier}))'
        return f'{flag.identifier}({flag.identifier})'

    assigned_vals = '\n  , '.join(assigned_val(flag) for flag in flags)

    h_config = f'''
#pragma once
#include <cstdint>
#include <boost/program_options/variables_map.hpp>

namespace po = boost::program_options;

namespace {PROJECT_NAMESPACE} {{

namespace config {{
extern po::variables_map FLAG_STORE;
}}  // namespace config

namespace {module} {{

typedef struct config_t{{
  {type_decls}

  // use this ctor for production
  config_t()
  : {configured_vals}
  {{}}
  
  // use this ctor for tests (skipping argv and config.ini)
  // dummy's only purpose is to avoid signature overlap
  explicit config_t(bool dummy, {param_decls})
  : {assigned_vals}
  {{
    (void) dummy;
  }}
        
}} config_t;
}}  // namespace {module}
}}  // namespace {PROJECT_NAMESPACE}
    '''
    return HEADER_COMMENT + h_config


def generate_module_config(path: str, module: str, flags: [Flag]):
    module_path = os.path.join(path, module)
    with open(os.path.join(module_path, 'config.h'), 'w') as file:
        file.write(module_config_str(module, flags))


def should_regen_cpp(path: str):
    cc_path = os.path.join(path, 'config.cc')
    if not os.path.exists(cc_path):
        return True
    return os.path.getmtime(os.path.join(path, 'config.ini')) > os.path.getmtime(cc_path)


# only generate this file if one does not already exist
def missing_config(path: str):
    filename = os.path.join(path, 'config.ini')
    return not os.path.exists(filename)


def generate_default_config(path: str, flags: [Flag]):
    cp = configparser.ConfigParser()
    for flag in flags:
        if flag.module not in cp.sections():
            cp[flag.module] = {}
        cp[flag.module][flag.identifier] = flag.val
        if flag.val[0] == '"':
            cp[flag.module][flag.identifier] = flag.val[1:-1]

    with open(os.path.join(path, 'config.ini'), 'w') as file:
        file.write('''# This file allows you to set config flags to non-default values
#
# The syntax is identical to src/config/config.ini with the following note
# DO NOT SPECIFY type:
# type flag_name = value WILL NOT BE RECOGNIZED

''')
        cp.write(file)


def main():
    path = sys.argv[1]
    config_path = os.path.join(path, 'config')
    should_regen = should_regen_cpp(config_path)
    should_gen_config = missing_config(sys.argv[2])

    if not should_regen and not should_gen_config:
        return

    try:
        modules, flags = parse_config(os.path.join(config_path, 'config.ini'))

        if should_gen_config:
            print('generating default config.ini in build directory')
            generate_default_config(sys.argv[2], flags)

        if not should_regen:
            return

        print('generating config.cc and module config.h')
        generate_main_config(config_path, modules, flags)
        for module in modules:
            generate_module_config(path, module, [flag for flag in flags if flag.module == module])

    # don't print call stack on ValueError because it's an input problem not a script problem
    except Exception as e:
        print(e)
        sys.exit(1)


if __name__ == '__main__':
    main()
